# MySQL

# MySQL组件

## 数据库和数据库实例

1. 在MySQL的学习研究中，存在两个非常容易混淆的概念，即数据库和数据库实例。在MySQL中，数据库和数据库实例定义如下：
   -  数据库：存储数据的集合
   - 数据库实例：操作数据库的集合
2. 数据库是用来存储数据的，数据库实例是用来操作数据的
3. 从操作系统的角度，数据库实例表现为一个进程，对应多个线程
4. 在非集群数据库架构中，数据库与数据库实例存在一一对应关系，在数据库集群中，可能存在多个数据库实例操作一个数据库情况，即多对一关系

## MySQL基架

1. MySQL基架大致包括如下几大模块组件：
   - **MySQL向外提供的交互接口（Connectors）**：为各个语言提供统一的接口，如Java可通过jdbc来操作MySQL数据库，C可以通过odbc来操作MySQL数据库
   - **管理服务组件和工具组件(Management Service & Utilities)**：如备份(Backup),恢复(Recovery),安全管理(Security)等
   - **连接池组件(Connection Pool)**：所有的成功连接都有连接池统一管理
   - **SQL接口组件(SQL Interface)**：接收用户SQL命令，如DML,DDL和存储过程等，并将最终结果返回给用户
   - **查询分析器组件(Parser)**：分析SQL命令语法的合法性，并尝试将SQL命令分解成数据结构，若分解失败，则提示SQL语句不合理
   - **优化器组件（Optimizer）**：对SQL命令按照标准流程进行优化分析
   - **缓存主件（Caches & Buffers）**：缓存和缓冲组件
   - **插件式存储引擎（Pluggable Storage Engines）**：mysql的存储引擎
   - **物理文件（File System）**：实际存储MySQL 数据库文件和一些日志文件等的系统，如Linux，Unix,Windows等。

# 存储引擎

## 概念

1.  MySQL属于关系型数据库，而关系型数据库的存储是以表的形式进行的，对于表的创建，数据的存储，检索，更新等都是由MySQL存储引擎完成的，这也是MySQL存储引擎在MySQL中扮演的重要角色。

2. SQL Server和Oracle这两种数据库的存储引擎只有一个，而MySQL的存储引擎种类比较多，如MyISAM存储

   引擎，InnoDB存储引擎和Memory存储引擎

3. MySQL之所以有多种存储引擎，是因为MySQL的开源性决定的。MySQL存储引擎，从种类上来说，大致可归结为官方存储引擎和第三方存储引起。MySQL的开源性，允许第三方基于MySQL骨架，开发适合自己业务需求的存储引擎

## 作用

1. 管理表创建，数据检索，索引创建等
2. 满足自定义存储引擎开发。

## 引擎种类

1.  InnoDB：MySql 5.6 版本默认的存储引擎，支持事务、恢复、锁、聚集索引、外键约束
2. MyISAM：默认表级锁，适用于以读为主的数据场景
3. Memory：内存数据引擎，用于快速查找；一般不用
4. CSV：类似CSV文件，没有索引等
5. Archive
6. NDB（NDBCLUSTER）：类似于redis，少量版本支持，目前正处于研发阶段
7. Merge
8. Federated
9. Example：支持自定义存储引擎

# 索引

## 索引种类

1. 索引存储类型：
   - B-（B+）Tree索引：InnoDB使用的就是B+Tree
   - 聚簇索引：InnoDB支持聚簇索引，MyISAM不支持聚簇索引
   - Hash索引：Memory支持
   - R-Tree（空间索引）：MyISAM支持空间索引
   - Full-text（全文索引）：MyISAM支持，InnoDB5.6以后支持，但不支持中文索引，只一点可以使用插件
2. MySQL索引类型：
   - 普通索引：允许有重复值和空值
   - 唯一索引：不允许有重复值，允许空值
   - 主键索引：唯一且不为空，一个表只有一个主键索引
   - 外键索引：MySQL会自动为定义了外键约束的字段加上外键索引
   - 组合索引：组合使用的索引，组合必须唯一

## 索引的优缺点

1. 优点
   - 索引大大减小了服务器需要扫描的数据量
   - 索引可以帮助服务器避免排序和临时表
   - 索引可以将随机IO变成顺序IO
   - 索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。 InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即索引达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。
   - 关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）
2. 缺点
   - 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。
   - 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
   - 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
   - 对于非常小的表，大部分情况下简单的全表扫描更高效

## 索引优化

1. 数据库设计方面
   - 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引；
   - 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num = 0；
   - 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用；
   - 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要；
   - 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引；
   - 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了；
   - 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些；
   - 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）；
   - 避免频繁创建和删除临时表，以减少系统表资源的消耗；
   - 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表;
   - 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert；
   - 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。
2. SQL语句方面
   - 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描；
   - 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20;
   - in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3；
   - 下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’
   - 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num；
   - 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2；
   - 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’–name以abc开头的id，select id from t where datediff(day,createdate,’2005-11-30′)=0–‘2005-11-30’生成的id 应改为: select id from t where name like ‘abc%’ select id from t where createdate>=’2005-11-30′ and createdate<’2005-12-1′
   - 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
   - 不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(…)
   - 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num)
   - 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。
   - 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。
   - 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
   - 尽量避免大事务操作，提高系统并发能力。

# 事务

## ACID

1. 事务具有四个特性，即：
   - 原子性（ Atomicity ）
   - 一致性（ Consistency ）
   - 隔离性（ Isolation ）
   - 持续性（ Durability ）
2. 原子性：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做
3. 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
4. 隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
5. 持续性：也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

## 隔离级别

1. SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。四种隔离级别如下：
   - 读未提交（Read Uncommitted）
   - 读已提交（Read Committed）
   - 可重复度（Repeatable Read）
   - 可串行化（Serializable）
2. 读未提交：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
3. 读已提交：这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
4. 可重复度：这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multi Version Concurrency Control）机制解决了该问题。
5. 可串行化：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
6. MVCC： 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。

## 导致的问题

1. 四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题，主要会导致三个问题：

   - 脏读(Drity Read)
   - 不可重复读（虚读）(Non-repeatable read)
   - 幻读(Phantom Read)

2. 脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。后面可能出现了数据回滚，从而导致了脏读

3. 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。

   解决办法：如果只有在修改事务完全提交之后才可以读取数据，则可以避免该问题。

4. 幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

   解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题

5. 各个隔离级别能解决的问题：

   | 隔离级别 | 脏读      | 不可重复读 | 幻读 |
   | -------- | --------- | ---------- | ---- |
   | 读未提交 | ×(未解决) | ×          | ×    |
   | 读已提交 | √(解决)   | ×          | ×    |
   | 可重复读 | √         | √          | ×    |
   | 可串行化 | √         | √          | √    |

# 锁

## 锁机制

1. 锁的特点：
   - 锁是计算机协调多个进程或线程并发访问某一资源的机制。
   - 锁保证数据并发访问的一致性、有效性
   - 锁冲突也是影响数据库并发访问性能的一个重要因素
   - 锁是Mysql在服务器层和存储引擎层的的并发控制。
   - 加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否是否已解除、释放锁等
2. 一些锁的概念：
   - 共享锁（读锁）：其他事务可以读，但不能写。
   - 排他锁（写锁）：其他事务不能读，也不能写。
   - 粒度锁：不同粒度级别的锁，主要有：
     - 表级锁
     - 行级锁
     - 页面锁
   - 死锁：两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。
   - 乐观锁：乐观的认为拿数据时别人不会修改，所以不加锁
   - 悲观锁：悲观的认为拿数据时别人总会修改，每次操作都加锁

## 粒度锁

1. MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：
   - MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）
   - BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁
   - InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁
2. 默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。
3. 不同粒度级别的锁的比较：
   - 表级锁：并发度最低，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高；适用于以查询为主，并发少的场景
   - 行级锁：并发度最高，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低；最大程度支持并发
   - 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
4. 此外，MySQL还有全局锁，是对于整个数据库进行加锁，一般用于数据库备份

## 加锁

1. 对数据进行查询操作时，不会加任何锁
2. 对数据进行增删改时，默认会给涉及的数据加行级锁，不过这个条件很严格
3. 对数据进行增删改时，都会给涉及的数据加集体排它锁
4. 对表进行结构操作时，会加表锁，不规律的增删改查也会加到表锁上

## 索引机制

1. InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁；即更新数据时，更新的条件并非是索引列，此时加表锁；如果是索引列（比如主键id），会加行锁
2. 如果有大量的更新操作，会出现批量行锁，性能严重下降，此时MySQL会将锁升级为表锁，就用不到索引了
3. 间隙锁：如果增删改的条件是在某一个范围之内，那么这个访问之内的数据都会被锁住，即使数据不存在，比如update ... where id<10，但不存在某一行数据的id=8，即使有其他操作是操作id=8的，这也是不允许的，

